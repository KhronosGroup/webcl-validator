Some notes about the system and how does it work
================================================

Coding guidelines for programmer to avoid checks
------------------------------------------------

Avoid having to use unneccessary amount of 
*(), -> or [] operators, each of them causes check to be added to
code.

NOTE: in the future dependecy analysis can help to remove checks if many cases  


What memory accesses are recognized and how are they made safe
--------------------------------------------------------------

First all types of accesses are recognized and normalized to *() access

table[index]; -> (*(table + index));

struct_ptr->field; -> (*(struct_ptr)).field;

vector_type_ptr->x -> (*(vector_type_ptr)).x;

*(any_pointer); -> *(any_pointer);

Then the address inside *() notation is clamped to correct range:

*(WCL_CLAMP((type), ptr, min_ptr, max_ptr))


Memory zero initialization
--------------------------

* local memory is zeroed in start of each workitem

* private memory is zeroed in start of each workitem, if secure way
  is found for statically allocated constant memory initialization, 
  that method should be able to be used for private memory as well. 

ISSUE: How to avoid padding leakage for global variable initialization 
       without making assumptions of device architecture:

https://www.securecoding.cert.org/confluence/display/seccode/DCL39-C.+Avoid+information+leak+in+structure+padding

Which variable declarations must be collected to address space
--------------------------------------------------------------

* In the first phase all of them.

* Also if function argument is passed to other function as pointer,
new variable must be created for it to address space struct and 
add assignment to start of function

e.g. void foo(int bar) {
    foo2(&bar);
}

- transformed to ->

void foo(int bar) {
    wcl_allocs->pa.foo__bar = bar;
    foo2(&wcl_allocs->pa.foo__bar);
}


What other information analysis pass should collect
----------------------------------------------------

* Find out which calls are builtin calls and which ones
  are calls to internal functions.

* Find out type of each pointer that is accessed by * operator
  to be able to figure out the worst case limits.


What kind of other checks are done to validate the webcl
----------------------------------------------------------

* Check that only list of preprocessor directives that we allow 
  pass through.

* 3d image type is not supported.

* TODO: double underscore is not allowed in kernel arguments (because of our naming scheme)

*. TODO: add some more info about checks 


What additional transformations are needed
------------------------------------------

* all typedefs are collected and located to start of source in the 
original order (our own typedefs needs to be injected after originals)

TODO:

* Add list / checks of allowed preprocessor directives 

* Create address space specific null pointers and code to initialize them.

* add converter which adds padding to constant address space struct initializer

* fix private memory initializers (support only basic types and arrays)

FUTURE:

* Add dependecy analysis to follow dependencies of limits to respect
  between function calls.

* Inject safe builtin implementations, for the builtin functions which
  might access memory evil ways (probably we need to generate code on the 
  fly if multiple limits to check). 

* Add separate version of helper functions for each kernel and create
  different limit structures for each kernel. 

* Find worst case scenario from call graph about needed private memory
  and write stack emulation, instead of having all the private variables
  separately in provate address space struct

* Add value range analysis to be able to remove checks out from loops and
  to start of program or in extreme case completely create pre-validation 
  kernel, which checks that arguments are ok before just executing the code 
  (this would allow e.g. autovectorization to work normally).


Implementation details and brief intro to code base
====================================================

Magic starts with main.cpp: We create our WebCLAction and run it with webclTool.

    clang::tooling::ClangTool webclTool(optionsParser.GetCompilations(),
                                        optionsParser.GetSourcePathList());

    clang::tooling::FrontendActionFactory *webCLActionFactory = 
        clang::tooling::newFrontendActionFactory<WebCLAction>();

    const int status = webclTool.run(webCLActionFactory);

WebCLAction.cpp: Does initialize some classes, most importantly WebCLConsumer, which coordinates 
all the hard work to different pieces.

WebCLConsumer.cpp: 

Calls all visitors to analyse and interpret AST tree. WebCLAnalyser is the visitor, which collects 
all the information that is needed for the few handler classes to be able to model the address 
spaces, dynamic memory got from kernel arguments and memory accesses in the program.

This all is done in WebCLConsumer::HandleTranslationUnit method.

Handler classes calls internally WebCLTransformer to do required changes to code. To keep system 
simple and brains in one place transformer does not know anything about state between calls. It does 
only single transformations to source according to data provided by handler classes.

Currently design has following handlers:

InputNormaliser: This class just moves typedefs to start of module so that typedefs are 
                 available when defining types of address spaces.

HelperFunctionHandler: Adds additinal parameter to every helper function signature and to calls
                       of internal functions.

AddressSpaceHandler: Collects information about which variables must be collected to each address space
                     and if necessary organizes order of data and adds explicit paddin bytes to prevent
                     information leakage. Class also does relocations of variable uses to refer address
                     space equivalents instead.

KernelHandler: Class collects information of every limit that exists in program and contains information
               which limits each variable use should respect. Limits are collected from AddressSpaceHandler
               and from pointers passed to kernel arguments. Class also creates initialization code for
               each kernel, where static allocations of private and local address space data are done.

MemoryAccessHandler: This class knows everything about memory accesses and uses limit information got from
                     kernel handler to inject memory access clamping macro calls.

WebCLTransformer.cpp: Handler classes use transformer to create all simple transformations.
This should be mostly brainless class that e.g. knows how relocation is done, but does not
know if it should be done. 

Does the hard work of keeping track generated prologues of every function / kernel and
module prologue. Provides easy API for handlers to be able to create transformations
required by the algorithm, but does not store internally data about program structure. 




