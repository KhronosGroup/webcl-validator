/*
** Copyright (c) 2013 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

#include "WebCLDebug.hpp"
#include "WebCLTransformer.hpp"
#include "WebCLVisitor.hpp"
#include "WebCLPass.hpp"
#include "WebCLTypes.hpp"
#include "general.h"

#include "clang/AST/Attr.h"
#include "clang/Basic/OpenCL.h"
#include "clang/AST/Type.h"
#include "clang/AST/ASTContext.h"
#include "clang/AST/Expr.h"
#include "clang/AST/TypeLoc.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Rewrite/Core/Rewriter.h"

namespace {
    typedef std::vector<clang::Expr*> ExprVector;
    typedef std::list<std::pair<std::string, std::string> > FunctionArgumentList;

    // Stores the return type and body of the generated function. The declaration of the function
    // is generated by function functionDeclaration.
    struct WrappedFunction {
	bool doWrap_;
    bool addAddressSpaceRecordArg_;
	std::string returnTypeStr_;
	std::string body_;

	// perform no wrapping
	WrappedFunction();

	// wrap with this return type and body (declaration is created by functionDeclaration)
	WrappedFunction(std::string returnTypeStr, std::string body, bool addAddressSpaceRecordArg);
    };

    WrappedFunction::WrappedFunction() :
	doWrap_(false), addAddressSpaceRecordArg_(true)
    {
	// nothing
    }

    WrappedFunction::WrappedFunction(std::string returnTypeStr, std::string body, bool addAddressSpaceRecordArg = true) :
	doWrap_(true), addAddressSpaceRecordArg_(addAddressSpaceRecordArg), returnTypeStr_(returnTypeStr), body_(body)
    {
	// nothing
    }
}

WebCLTransformer::ClampFunctionKey::ClampFunctionKey(unsigned aSpaceNum, unsigned limitCount, std::string type) :
    aSpaceNum(aSpaceNum), limitCount(limitCount), type(type)
{
    // nothing
}

bool WebCLTransformer::ClampFunctionKey::operator<(const ClampFunctionKey& other) const
{
    return 
        (aSpaceNum < other.aSpaceNum)   ? true :
        (aSpaceNum > other.aSpaceNum)   ? false :
        (limitCount < other.limitCount) ? true :
        (limitCount > other.limitCount) ? false :
        (type < other.type)             ? true :
        (type > other.type)             ? false :
        false;
}

class WebCLTransformer::FunctionCallWrapper {
public:
    FunctionCallWrapper();

    virtual ~FunctionCallWrapper();

    /// Return the name of the builtin function
    virtual std::string getName() const = 0;
    /// Return the number of arguments the builtin function accepts
    virtual unsigned getNumArgs() const = 0;

    /// Does this wrapper match the signature of the call?
    virtual bool matchesCallExpr(clang::CompilerInstance &instance, clang::CallExpr *callExpr);

    /// Does this wrapper match the signature of this variable declaration?
    virtual bool matchesVarDecl(clang::CompilerInstance &instance, clang::VarDecl *varDecl);
	
    /// Returns the return type and body of the builtin function with given arguments.
    /// Declaration for the function is generated by the function functionDeclaration
    virtual WrappedFunction wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const;

    /// Returns the return type and body of the builtin function with given arguments.
    /// Declaration for the function is generated by the function functionDeclaration
    virtual void wrapDeclaration(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::VarDecl *varDecl, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const;

public:
    /// cannot be copied, this code doesn't exist
    FunctionCallWrapper(const FunctionCallWrapper&);

    /// cannot be copied, this code doesn't exist
    void operator=(const FunctionCallWrapper&);
};

WebCLTransformer::FunctionCallWrapper::FunctionCallWrapper()
{
// nothing    
}

WebCLTransformer::FunctionCallWrapper::~FunctionCallWrapper()
{
// nothing    
}

bool WebCLTransformer::FunctionCallWrapper::matchesCallExpr(clang::CompilerInstance &instance, clang::CallExpr *callExpr)
{
    const clang::FunctionDecl *callee = callExpr->getDirectCallee();
    std::string callName = callee->getNameInfo().getAsString();
    return getName() == callName && getNumArgs() == callExpr->getNumArgs();
}

bool WebCLTransformer::FunctionCallWrapper::matchesVarDecl(clang::CompilerInstance &instance, clang::VarDecl *varDecl)
{
    return false;
}

WrappedFunction WebCLTransformer::FunctionCallWrapper::wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const
{
    return WrappedFunction();
}

void WebCLTransformer::FunctionCallWrapper::wrapDeclaration(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::VarDecl *varDecl, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const
{
    // nothing
}

namespace {
    // Does the type name of the nth argument of a call OR the function that is
    // being called match the given type name?
    bool argTypeMatchesCallerOrCalleeArg(clang::CompilerInstance &instance, clang::CallExpr *callExpr, size_t argIdx, std::string typeName) {
        const clang::FunctionDecl *callee = callExpr->getDirectCallee();
        if (argIdx < callExpr->getNumArgs() && WebCLTypes::reduceType(instance, callExpr->getArg(argIdx)->getType()).getAsString() == typeName) {
            return true;
        } else if (argIdx < callee->getNumParams()) {
            const clang::ParmVarDecl *paramVarDecl = callee->getParamDecl(argIdx);
            const clang::QualType paramQualType = paramVarDecl->getOriginalType();
            return WebCLTypes::reduceType(instance, paramQualType).getAsString() == typeName;
        } else {
            return false;
        }
    }

    // Rewrites a sampler argument to a function. If it is an integer constant expression it is rewritten as an or expression.
    // if it is a reference to a function argument it is passed as-is.
    // otherwise an error is produced.
    void rewriteOrForwardSamplerArgument(WebCLTransformer &transformer, clang::CompilerInstance &instance, WebCLRewriter &rewriter,
        clang::SourceRange range, clang::Expr *argExpr, clang::SourceLocation location /* for reporting */)
    {
        const char* typeName = "sampler_t";
        llvm::APSInt apsValue;
        if (argExpr->isIntegerConstantExpr(apsValue, instance.getASTContext())) {
            uint64_t value = apsValue.getLimitedValue();
            // #define CLK_ADDRESS_NONE                            0x00
            // #define CLK_ADDRESS_MIRRORED_REPEAT                 0x01
            // #define CLK_ADDRESS_REPEAT                          0x02
            // #define CLK_ADDRESS_CLAMP_TO_EDGE                   0x03
            // #define CLK_ADDRESS_CLAMP                           0x04
            // #define CLK_NORMALIZED_COORDS_FALSE                 0x00
            // #define CLK_NORMALIZED_COORDS_TRUE                  0x08
            // #define CLK_FILTER_NEAREST                          0x00
            // #define CLK_FILTER_LINEAR                           0x10
            bool normalized = value & 0x08;
	    bool filter = value & 0x10;
	    int address = value & 0x07;
	    uint64_t remaining = value - (normalized * 0x08) - (filter * 0x10) - address;
            if (address == 0) {
                transformer.error(location, "CLK_ADDRESS_NONE is not a valid address mode for %0") << typeName;
            } else if (address < 0 || address > 4 || remaining != 0) {
                transformer.error(location, "%0 is not a valid constant value for %1") << stringify(value) << typeName;
	    } else {
		std::stringstream d;
		d << "/* transformed */ ";
                switch (address) {
                case 0x00: d << "CLK_ADDRESS_NONE"; break;
                case 0x01: d << "CLK_ADDRESS_MIRRORED_REPEAT"; break;
                case 0x02: d << "CLK_ADDRESS_REPEAT"; break;
                case 0x03: d << "CLK_ADDRESS_CLAMP_TO_EDGE"; break;
                case 0x04: d << "CLK_ADDRESS_CLAMP"; break;
                }
                
                d << " | " << (filter ? "CLK_FILTER_LINEAR" : "CLK_FILTER_NEAREST");
                d << " | " << (normalized ? "CLK_NORMALIZED_COORDS_TRUE" : "CLK_NORMALIZED_COORDS_FALSE");
                
                // this does not work due to macros confusing the framework:
                // rewriter.replaceText(argExpr->getSourceRange(), d.str());
                // The following does not quite work either:
                // rewriter.replaceText(
                //     clang::SourceRange(
                //         arguments[0]->getLocStart(), 
                //         arguments[0]->getLocStart()// .getLocWithOffset(-1)
                //     ),
                //     d.str() + ",");

                // So we use our code that retrieves the source ranges from the source text:
                rewriter.replaceText(range, d.str());
            }
        } else {
            // accept expression as-is if it is directly (or via an implicit conversion) a parameter of the function
            clang::DeclRefExpr *declRefExpr = clang::dyn_cast<clang::DeclRefExpr>(argExpr);
            if (!declRefExpr) {
                if (clang::ImplicitCastExpr *implicitCastExpr = clang::dyn_cast<clang::ImplicitCastExpr>(argExpr)) {
                    declRefExpr = clang::dyn_cast<clang::DeclRefExpr>(*implicitCastExpr->child_begin());
                }
            }

            const clang::ValueDecl *valueDecl = declRefExpr ? declRefExpr->getDecl() : 0;
            
            if (valueDecl && WebCLTypes::reduceType(instance, valueDecl->getType()).getAsString() != typeName) {
                transformer.error(location, "initializer is not of type %0") << typeName;
            } else if (valueDecl && clang::isa<clang::ParmVarDecl>(valueDecl)) {
                // ok, this value is directly (or implicitly casted) parameter reference
            } else if (valueDecl && clang::isa<clang::VarDecl>(valueDecl)) {
                // ok, this value is directly (or implicitly casted) variable reference
            } else {
                transformer.error(location, "%0 is not a constant integer expression or originate from function parameters") << typeName;
            }
        }
    }

    class VLoad: public WebCLTransformer::FunctionCallWrapper {
    public:
        VLoad(unsigned width, bool half, bool aligned);

	std::string getName() const;
	unsigned getNumArgs() const;

	WrappedFunction wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const;

    private:
	unsigned	width_;
	bool		half_;
        bool            aligned_;
    };

    class VStore: public WebCLTransformer::FunctionCallWrapper {
    public:
	VStore(unsigned width, bool half, bool aligned, std::string roundingMode);

	std::string getName() const;
	unsigned getNumArgs() const;

	WrappedFunction wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const;

    private:
	unsigned	width_;
	bool		half_;
        bool            aligned_;
	std::string     roundingMode_;
    };

    class SamplerType: public WebCLTransformer::FunctionCallWrapper {
    public:
        SamplerType();

        std::string getName() const;
        unsigned getNumArgs() const;

        bool matchesCallExpr(clang::CompilerInstance &instance, clang::CallExpr *callExpr);
        bool matchesVarDecl(clang::CompilerInstance &instance, clang::VarDecl *callExpr);

        WrappedFunction wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const;
        void wrapDeclaration(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::VarDecl *varDecl, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const;

    private:
    };

    class ReadImage: public WebCLTransformer::FunctionCallWrapper {
    public:
	ReadImage(std::string suffix);

	std::string getName() const;
	unsigned getNumArgs() const;

	WrappedFunction wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const;

    private:
	std::string suffix_; // "f" or "i"
    };

    class WriteImage: public WebCLTransformer::FunctionCallWrapper {
    public:
	WriteImage(std::string suffix);

	std::string getName() const;
	unsigned getNumArgs() const;

	WrappedFunction wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const;

    private:
	std::string suffix_; // "f" or "i" or "ui"
    };

    // GenericWrapper creates a generic wrapper for function with exactly pointer one argument (and possibly other
    // arguments)
    class GenericWrapper: public WebCLTransformer::FunctionCallWrapper {
    public:
        /// @param name          Name of the function to wrap
        /// @param numArgs       Number of arguments in the function
        /// @param ptrArgIndex   Index of the argument with the pointer type to check (zero = first argument)
        /// @param returnTypeStr Index of the argument that determines the return type of the function. If it is the
        ///                      same as ptrArgIndex, the pointer is dereferenced for determining the return type.
        GenericWrapper(std::string name, unsigned numArgs, unsigned ptrArgIndex, unsigned returnTypeArgIndex);

        std::string getName() const;
        unsigned getNumArgs() const;

        WrappedFunction wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const;

    private:
        std::string     name_;
        unsigned        numArgs_;
        unsigned        ptrArgIndex_;
        unsigned        returnTypeArgIndex_;
    };


    VLoad::VLoad(unsigned width, bool half, bool aligned) :
	width_(width), half_(half), aligned_(aligned)
    {
	// nothing
    }

    std::string VLoad::getName() const
    {
	std::stringstream ss;
	ss << "vload";
        if (aligned_) {
            ss << "a";
        }
	if (half_) {
	    ss << "_half";
	}
	if (width_ != 1) {
	    ss << width_;
	}
	return ss.str();
    }

    unsigned VLoad::getNumArgs() const
    {
	return 2;
    }

    std::string functionDeclaration(
	std::string returnType,
	std::string name,
	FunctionArgumentList arguments)
    {
	std::stringstream result;

	result << returnType << " " << name << "(";
	for (FunctionArgumentList::const_iterator argIt = arguments.begin();
	     argIt != arguments.end();
	     ++argIt) {
	    if (argIt != arguments.begin()) {
		result << ", ";
	    }
	    result << argIt->first << " " << argIt->second;
	}
	result << ")";

	return result.str();
    }

    std::string wrappedDeclaration(
        clang::CompilerInstance &instance, 
        std::string returnTypeStr,
        const clang::CallExpr *callExpr, 
        std::string name,
    bool addAddressSpaceRecordArg)
    {
        WebCLConfiguration cfg;

        FunctionArgumentList newArguments;
      
        if (addAddressSpaceRecordArg) {
            newArguments.push_back(std::make_pair(cfg.addressSpaceRecordType_ + "*", cfg.addressSpaceRecordName_));
        }
      
        for (size_t argIdx = 0; argIdx < callExpr->getNumArgs(); ++argIdx) {
            const clang::Expr *expr = callExpr->getArg(argIdx);
            const clang::DeclRefExpr *declRefExpr = WebCLTypes::declRefExprViaImplicit(expr);

            std::string imageQualifiers;

            if (declRefExpr) {
                const clang::Decl *decl = declRefExpr->getDecl();
                if (decl->hasAttr<clang::OpenCLImageAccessAttr>()) {
                    int qualifier = decl->getAttr<clang::OpenCLImageAccessAttr>()->getAccess();
                    imageQualifiers =
                        qualifier == clang::CLIA_read_only ? "read_only " :
                        qualifier == clang::CLIA_write_only ? "write_only " :
                        qualifier == clang::CLIA_read_write ? "read_write " :
                        "";
                    assert(!qualifier || imageQualifiers.size());
                }
            }

            newArguments.push_back(std::make_pair(
                    imageQualifiers + expr->getType().getAsString(),
                    "arg" + stringify(argIdx)));
        }
        
        return functionDeclaration(returnTypeStr, name, newArguments);
    }

    WrappedFunction VLoad::wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const
    {
	WebCLConfiguration cfg;

	clang::Expr *pointerArg = arguments[1];

	if (!pointerArg->getType()->isPointerType()) {
	    transformer.error(arguments[1]->getLocStart(), "%0 argument number 2 must be a pointer") << getName().c_str();
	    return WrappedFunction();
	}

	std::string ptrTypeStr = pointerArg->getType().getAsString();
	std::string returnTypeStr;
	unsigned origDataWidth = (aligned_ && width_ == 3) ? 4 : width_;

	if (half_) {
	    returnTypeStr = "float" + stringify(width_);
	} else {
	    returnTypeStr = WebCLTypes::reduceType(instance, pointerArg->getType().getTypePtr()->getPointeeType()).getAsString();
	}
	
	AddressSpaceLimits &limits = kernelHandler.getDerefLimits(pointerArg);

	std::string indent = cfg.getIndentation(1);
	std::string indent__ = cfg.getIndentation(2);
	std::stringstream body;
	std::string zeroValue;
	if (!WebCLTypes::initialZeroValues().count(returnTypeStr)) {
	    transformer.error(arguments[1]->getLocStart(), ("Cannot find default zero initializer for type " + returnTypeStr).c_str());
	} else {
	    zeroValue = WebCLTypes::initialZeroValues().find(returnTypeStr)->second;
	}
	body
	    << indent << ptrTypeStr << " ptr = arg1 + " << origDataWidth << " * (size_t) arg0;\n"
	    << indent << "if (" << transformer.getCheckFunctionCall(WebCLTransformer::CHECK_CHECK, "ptr", ptrTypeStr, origDataWidth, limits) << ")\n"
	    << indent__ << "return " << getName() << "(0, ptr);\n"
	    << indent << "else\n"
	    << indent__ << "return " << zeroValue << ";\n";

	return WrappedFunction(returnTypeStr + stringify(width_), body.str());
    }

    VStore::VStore(unsigned width, bool half, bool aligned, std::string roundingMode) :
	width_(width), half_(half), aligned_(aligned), roundingMode_(roundingMode)
    {
	// nothing
    }

    std::string VStore::getName() const
    {
	std::stringstream ss;
	ss << "vstore";
        if (aligned_) {
            ss << "a";
        }
	if (half_) {
	    ss << "_half";
	}
	if (width_ != 1) {
	    ss << width_;
	}
	if (roundingMode_.size()) {
	    ss << "_" << roundingMode_;
	}
	return ss.str();
    }

    unsigned VStore::getNumArgs() const
    {
	return 3;
    }

    WrappedFunction VStore::wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const
    {
	WebCLConfiguration cfg;

	clang::Expr *pointerArg = arguments[2];

	if (!pointerArg->getType()->isPointerType()) {
	    transformer.error(arguments[1]->getLocStart(), "%0 argument number 2 must be a pointer") << getName().c_str();
	    return WrappedFunction();
	}

	std::string ptrTypeStr = pointerArg->getType().getAsString();
	unsigned origDataWidth = (aligned_ && width_ == 3) ? 4 : width_;
	
	AddressSpaceLimits &limits = kernelHandler.getDerefLimits(pointerArg);

	std::string indent = cfg.getIndentation(1);
	std::string indent__ = cfg.getIndentation(2);
	std::stringstream body;
	body
	    << indent << ptrTypeStr << " ptr = arg2 + " << origDataWidth << " * (size_t) arg1;\n"
	    << indent << "if (" << transformer.getCheckFunctionCall(WebCLTransformer::CHECK_CHECK, "ptr", ptrTypeStr, origDataWidth, limits) << ")\n"
	    << indent__ << getName() << "(arg0, 0, ptr);\n";

	return WrappedFunction("void", body.str());
    }

    ReadImage::ReadImage(std::string suffix) :
	suffix_(suffix)
    {
	// nothing
    }

    std::string ReadImage::getName() const
    {
	return "read_image" + suffix_;
    }

    unsigned ReadImage::getNumArgs() const
    {
	return 3;
    }

    WrappedFunction ReadImage::wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const
    {
	llvm::APSInt apsValue;
	clang::Expr *imageArg = arguments[0];
	clang::Expr *samplerArg = arguments[1];
	if (WebCLTypes::reduceType(instance, imageArg->getType()).getAsString() != "image2d_t") {
	    transformer.error(arguments[1]->getLocStart(), "%0 argument number 1 must be image2d_t") << getName().c_str();
	    return WrappedFunction();
	}
        WebCLRewriter::SourceRangeVector ranges = rewriter.getArgumentSourceRanges(callExpr);
        if (ranges.size() != arguments.size()) {
            transformer.error(callExpr->getLocStart(), "Unsupported expression to read_image");
        } else {
            rewriteOrForwardSamplerArgument(transformer, instance, rewriter, ranges[1], samplerArg, ranges[1].getBegin());
        }
        return WrappedFunction();
    }

    WriteImage::WriteImage(std::string suffix) :
	suffix_(suffix)
    {
	// nothing
    }

    std::string WriteImage::getName() const
    {
	return "write_image" + suffix_;
    }

    unsigned WriteImage::getNumArgs() const
    {
	return 3;
    }

    WrappedFunction WriteImage::wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const
    {
	WebCLConfiguration cfg;

	clang::Expr *imageArg = arguments[0];
	clang::Expr *coordArg = arguments[1];

	if (WebCLTypes::reduceType(instance, imageArg->getType()).getAsString() != "image2d_t") {
	    transformer.error(arguments[1]->getLocStart(), "%0 argument number 1 must be image2d_t") << getName().c_str();
	    return WrappedFunction();
	}

	if (WebCLTypes::reduceType(instance, coordArg->getType()).getAsString() != "int2") {
	    transformer.error(arguments[1]->getLocStart(), "%0 argument number 1 must be int2") << getName().c_str();
	    return WrappedFunction();
	}

	std::string indent = cfg.getIndentation(1);
	std::string indent__ = cfg.getIndentation(2);
	std::stringstream body;
        body
            << indent << "int2 size = get_image_dim(arg0);\n"
            << indent << "if (arg1.x >= 0 && arg1.y >= 0 && arg1.x < size.x && arg1.y < size.y)\n"
            << indent__ << getName() << "(arg0, arg1, arg2);\n";

	return WrappedFunction("void", body.str(), false);
    }

    SamplerType::SamplerType()
    {
        // nothing
    }

    std::string SamplerType::getName() const
    {
        return "sampler type handler";
    }

    unsigned SamplerType::getNumArgs() const
    {
        // not applicaple
        return 0;
    }

    bool SamplerType::matchesCallExpr(clang::CompilerInstance &instance, clang::CallExpr *callExpr)
    {
        for (size_t argIdx = 0; argIdx < callExpr->getNumArgs(); ++argIdx) {
            // either the argument or the function parameter type matchesCallExpr. this covers the case of implicit conversions
            // of, say, an integer to sampler_t
            if (argTypeMatchesCallerOrCalleeArg(instance, callExpr, argIdx, "sampler_t")) {
                return true;
	    }
        }
        return false;
    }

    WrappedFunction SamplerType::wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const
    {
        WebCLRewriter::SourceRangeVector ranges = rewriter.getArgumentSourceRanges(callExpr);
        if (ranges.size() != arguments.size()) {
            transformer.error(callExpr->getLocStart(), "Unsupported expression to function call involving sampler_t");
	} else {
            for (unsigned argIdx = 0; argIdx < arguments.size(); ++argIdx) {
                if (argTypeMatchesCallerOrCalleeArg(instance, callExpr, argIdx, "sampler_t")) {
                    rewriteOrForwardSamplerArgument(transformer, instance, rewriter, ranges[argIdx], arguments[argIdx], ranges[argIdx].getBegin());
                }
            }
	}
	return WrappedFunction();
    }

    bool SamplerType::matchesVarDecl(clang::CompilerInstance &instance, clang::VarDecl *varDecl)
    {
        return WebCLTypes::reduceType(instance, varDecl->getType()).getAsString() == "sampler_t";
    }

    void SamplerType::wrapDeclaration(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::VarDecl *varDecl, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const
    {
        if (!varDecl->getInit()) {
            transformer.error(varDecl->getLocStart(), "variables of type sampler_t must always be initialized");
        } else {
            rewriteOrForwardSamplerArgument(transformer, instance, rewriter,
                varDecl->getInit()->getSourceRange(), varDecl->getInit(), varDecl->getLocStart());
        }
    }

    GenericWrapper::GenericWrapper(std::string name, unsigned numArgs, unsigned ptrArgIndex, unsigned returnTypeArgIndex) :
        name_(name),
        numArgs_(numArgs),
        ptrArgIndex_(ptrArgIndex),
        returnTypeArgIndex_(returnTypeArgIndex)
    {
        // nothing
    }

    std::string GenericWrapper::getName() const
    {
        return name_;
    }

    unsigned GenericWrapper::getNumArgs() const
    {
        return numArgs_;
    }

    WrappedFunction GenericWrapper::wrapFunction(WebCLTransformer &transformer, clang::CompilerInstance &instance, clang::CallExpr *callExpr, const ExprVector &arguments, WebCLKernelHandler &kernelHandler, WebCLRewriter &rewriter) const
    {
        WebCLConfiguration cfg;

        clang::Expr *pointerArg = arguments[ptrArgIndex_];
        std::string ptrArgName = "arg" + stringify(ptrArgIndex_);

        if (!pointerArg->getType()->isPointerType()) {
            transformer.error(arguments[1]->getLocStart(), "%0 argument number %1 must be a pointer") << getName().c_str() << ptrArgIndex_ + 1;
            return WrappedFunction();
        }

        std::string ptrTypeStr = pointerArg->getType().getAsString();
        std::string returnTypeStr =
            ((returnTypeArgIndex_ == ptrArgIndex_) 
                ? WebCLTypes::reduceType(instance, pointerArg->getType().getTypePtr()->getPointeeType())
                : WebCLTypes::reduceType(instance, arguments[returnTypeArgIndex_]->getType())).getAsString();

        AddressSpaceLimits &limits = kernelHandler.getDerefLimits(pointerArg);

        std::string indent = cfg.getIndentation(1);
        std::stringstream body;
        std::string args;
        for (unsigned c = 0; c < numArgs_; ++c) {
            if (c) {
                args += ", ";
            }
            if (c == ptrArgIndex_) {
                args += transformer.getCheckFunctionCall(WebCLTransformer::CHECK_CLAMP, ptrArgName, ptrTypeStr, 1, limits);
            } else {
                args += "arg" + stringify(c);
            }
        }
        body << indent << "return " << name_ << "(" <<  args << ");\n";

        return WrappedFunction(returnTypeStr, body.str());
    }

}



WebCLTransformer::WebCLTransformer(
    clang::CompilerInstance &instance, clang::Rewriter &rewriter)
    : WebCLReporter(instance)
    , wclRewriter_(instance, rewriter)
    , cfg_()
{
    // Make a list of builtin wrappers
    for (UintList::const_iterator widthIt = cfg_.dataWidths_.begin();
	 widthIt != cfg_.dataWidths_.end();
	 ++widthIt) {
        functionWrappers_.push_back(new VLoad(*widthIt, false, false));
        functionWrappers_.push_back(new VStore(*widthIt, false, false, ""));
        functionWrappers_.push_back(new VLoad(*widthIt, true, false));
        functionWrappers_.push_back(new VStore(*widthIt, true, false, ""));
        functionWrappers_.push_back(new VLoad(*widthIt, true, true));
        functionWrappers_.push_back(new VStore(*widthIt, true, true, ""));
	for (StringList::const_iterator roundingModeIt = cfg_.roundingModes_.begin();
	     roundingModeIt != cfg_.roundingModes_.end();
	     ++roundingModeIt) {
            functionWrappers_.push_back(new VStore(*widthIt, true, false, *roundingModeIt));
            functionWrappers_.push_back(new VStore(*widthIt, true, true, *roundingModeIt));
	}
    }
    functionWrappers_.push_back(new VLoad(1, true, false));
    functionWrappers_.push_back(new VStore(1, true, false, ""));
    functionWrappers_.push_back(new VLoad(1, true, true));
    functionWrappers_.push_back(new VStore(1, true, true, ""));
    for (StringList::const_iterator roundingModeIt = cfg_.roundingModes_.begin();
	 roundingModeIt != cfg_.roundingModes_.end();
	 ++roundingModeIt) {
        functionWrappers_.push_back(new VStore(1, true, false, *roundingModeIt));
        functionWrappers_.push_back(new VStore(1, true, true, *roundingModeIt));
    }
    functionWrappers_.push_back(new ReadImage("f"));
    functionWrappers_.push_back(new ReadImage("i"));
    functionWrappers_.push_back(new WriteImage("f"));
    functionWrappers_.push_back(new WriteImage("i"));
    functionWrappers_.push_back(new WriteImage("ui"));

    addGenericWrappers(cfg_.atomicOperations1_, 1, 0);
    addGenericWrappers(cfg_.atomicOperations2_, 2, 0);
    addGenericWrappers(cfg_.atomicOperations3_, 3, 0);

    functionWrappers_.push_back(new GenericWrapper("fract", 2, 1, 0));
    functionWrappers_.push_back(new GenericWrapper("frexp", 2, 1, 0));
    functionWrappers_.push_back(new GenericWrapper("modf", 2, 1, 0));
    functionWrappers_.push_back(new GenericWrapper("lgamma_r", 2, 1, 0));
    functionWrappers_.push_back(new GenericWrapper("remquo", 3, 2, 0));
    functionWrappers_.push_back(new GenericWrapper("sincos", 2, 1, 0));

    // note: needs to be inserted after other, more specific, wrappers, as only the first matching handler is
    // executed. In this case this needs to be before ReadImage.
    functionWrappers_.push_back(new SamplerType());
}

void WebCLTransformer::addGenericWrappers(const StringList& list, 
    unsigned numArgs,
    unsigned ptrArgIndex)
{
    for (StringList::const_iterator operationIt = list.begin();
         operationIt != list.end();
         ++operationIt) {
        functionWrappers_.push_back(new GenericWrapper(*operationIt, numArgs, ptrArgIndex, ptrArgIndex));
    }
}

WebCLTransformer::~WebCLTransformer()
{
    for (FunctionPrologueMap::iterator i = kernelPrologues_.begin();
         i != kernelPrologues_.end(); ++i) {
        std::stringstream *out = i->second;
        delete out;
    }

    for (FunctionPrologueMap::iterator i = functionPrologues_.begin();
         i != functionPrologues_.end(); ++i) {
        std::stringstream *out = i->second;
        delete out;
    }

    for (FunctionCallWrapperList::iterator it = functionWrappers_.begin();
         it != functionWrappers_.end();
	 ++it) {
        delete *it;
    }
}

bool WebCLTransformer::rewrite()
{
    bool status = true;

    // do all replacements stored in refactoring first ()
    flushQueuedTransformations();

    status = status && rewritePrologue();
  
    std::set<const clang::FunctionDecl*> kernelOrFunction;
    for (FunctionPrologueMap::iterator iter = kernelPrologues_.begin();
         iter != kernelPrologues_.end(); iter++) {
      kernelOrFunction.insert(iter->first);
    }

    for (FunctionPrologueMap::iterator iter = functionPrologues_.begin();
       iter != functionPrologues_.end(); iter++) {
      kernelOrFunction.insert(iter->first);
    }
  
    for (std::set<const clang::FunctionDecl*>::iterator iter = kernelOrFunction.begin();
         iter != kernelOrFunction.end(); iter++) {

      const clang::FunctionDecl *func = *iter;
      clang::Stmt *body = func->getBody();
      if (!body) {
        error(func->getLocStart(), "Function has no body.");
        return false;
      }

      std::stringstream prologue;
      if (kernelPrologues_.count(func) > 0) {
          prologue << functionPrologue(kernelPrologues_, func).str();
      }
      if (functionPrologues_.count(func) > 0) {
          prologue << functionPrologue(functionPrologues_, func).str();
      }

      clang::SourceLocation loc = body->getLocStart();
      clang::SourceRange range(loc, loc);
      std::string orig = wclRewriter_.getTransformedText(range) + "\n";
      wclRewriter_.replaceText(range, orig + prologue.str());
    }

    flushQueuedTransformations();

    return status;
}

std::stringstream& WebCLTransformer::functionPrologue(
    FunctionPrologueMap &prologues, const clang::FunctionDecl *kernel)
{
    if (!prologues.count(kernel)) {
        std::stringstream *out = new std::stringstream();
        if (!out) {
            fatal("Internal error. Can't create stream for function prologue.");
            return modulePrologue_;
        }
        prologues[kernel] = out;
    }
    return *prologues[kernel];
}

std::string WebCLTransformer::addressSpaceInfoAsStruct(AddressSpaceInfo &as)
{
  std::stringstream retVal;
  retVal << "{\n";
  for (AddressSpaceInfo::iterator declIter = as.begin();
       declIter != as.end(); ++declIter) {
    retVal << cfg_.indentation_;
    emitVarDeclToStruct(retVal, (*declIter));
    retVal << ";\n";
  }
  retVal << "}";
  return retVal.str();
}

std::string WebCLTransformer::addressSpaceInitializer(AddressSpaceInfo &as) {
  std::stringstream retVal;
  retVal << "{ ";
  std::string comma = "";
  for (AddressSpaceInfo::iterator declIter = as.begin();
       declIter != as.end(); ++declIter) {
    retVal << comma;
    emitVariableInitialization(retVal, (*declIter));
    comma = ", ";
  }
  retVal << " }";

  DEBUG( std::cerr << "Created address space initializer: " << retVal.str() << "\n"; );
  return retVal.str();
}

std::string WebCLTransformer::addressSpaceLimitsAsStruct(AddressSpaceLimits &asLimits)
{
    std::stringstream retVal;
    retVal << "{\n";
  
    // if address space has static allocations
    if (asLimits.hasStaticallyAllocatedLimits()) {
        std::stringstream prefix;
        prefix << cfg_.indentation_ << "__";

        switch (asLimits.getAddressSpace()) {
        case clang::LangAS::opencl_constant:
            prefix << cfg_.constantAddressSpace_ << " "
                   << cfg_.constantRecordType_ << " *";
            retVal << prefix.str() << " "
                   << cfg_.constantMinField_ << ";\n";
            retVal << prefix.str() << " "
                   << cfg_.constantMaxField_ << ";\n";
            break;

        case clang::LangAS::opencl_local:
            prefix << cfg_.localAddressSpace_ << " "
                   << cfg_.localRecordType_ << " *";
            retVal << prefix.str() << " "
                   << cfg_.localMinField_ << ";\n";
            retVal << prefix.str() << " "
                   << cfg_.localMaxField_ << ";\n";
            break;

        default:
            break;
        }
    }
  
    for (AddressSpaceLimits::LimitList::iterator declIter = asLimits.getDynamicLimits().begin();
         declIter != asLimits.getDynamicLimits().end(); ++declIter) {
        clang::ParmVarDecl *decl = *declIter;

        retVal << cfg_.indentation_;
        emitVarDeclToStruct(retVal, decl, cfg_.getNameOfLimitField(decl, false));
        retVal << ";\n";

        retVal << cfg_.indentation_;
        emitVarDeclToStruct(retVal, decl, cfg_.getNameOfLimitField(decl, true));
        retVal << ";\n";
    }
    retVal << "}";
    return retVal.str();
}

std::string WebCLTransformer::addressSpaceLimitsInitializer(
    clang::FunctionDecl *kernelFunc, AddressSpaceLimits &asLimits)
{
    std::stringstream retVal;
    retVal << "{ ";
    std::string comma = "";

    // if address space has static allocations
    if (asLimits.hasStaticallyAllocatedLimits()) {
        std::string name = "&(&";
        
        switch (asLimits.getAddressSpace()) {
        case clang::LangAS::opencl_constant:
            name += cfg_.constantRecordName_ + ")";
            retVal << name << "[0], " << name << "[1]";
            comma = ",";
            break;

        case clang::LangAS::opencl_local:
            name += cfg_.localRecordName_ + ")";
            retVal << name << "[0], " << name << "[1]";
            comma = ",";
            break;

        case clang::LangAS::opencl_global:
            assert(false && "Global address space can't have static allocations.");
            break;

        default:
            assert((asLimits.getAddressSpace() == 0) &&
                   "Expected private address space.");
            break;
        }
    }

    for (AddressSpaceLimits::LimitList::iterator declIter = asLimits.getDynamicLimits().begin();
         declIter != asLimits.getDynamicLimits().end(); ++declIter) {

        retVal << comma;
        clang::ParmVarDecl *decl = *declIter;
        clang::FunctionDecl *func = llvm::dyn_cast<clang::FunctionDecl>(decl->getParentFunctionOrMethod());
        assert(func && "Parameter doesn't have a parent function.");
    
        if (func == kernelFunc) {
            const std::string name = decl->getName();
            retVal << "&" << name
                   << "[0], "
                   << "&" << name
                   << "[" << cfg_.getNameOfSizeParameter(name) << "]";
        } else {
            retVal << "0, 0";
        }
    
        comma = ",";
    }
    retVal << " }";
    return retVal.str();
}

void WebCLTransformer::createAddressSpaceLimitsNullInitializer(
    std::ostream &out, unsigned addressSpace)
{
  switch (addressSpace) {
    case clang::LangAS::opencl_constant:
    case clang::LangAS::opencl_local:
      out << cfg_.getNameOfAddressSpaceNull(addressSpace);
      break;
    default:
      out << "0";
  }
}

void WebCLTransformer::createAddressSpaceTypedef(
    AddressSpaceInfo &as, const std::string &name, const std::string &alignment)
{
    if (!as.empty()) {
        modulePrologue_ << "typedef struct "
                        << addressSpaceInfoAsStruct(as)
                        << " __attribute__ ((aligned (" << alignment << "))) " << name << ";\n\n";
    }
}

void WebCLTransformer::createPrivateAddressSpaceTypedef(AddressSpaceInfo &as)
{
    createAddressSpaceTypedef(as, cfg_.privateRecordType_, cfg_.getNameOfAlignMacro("private"));
}

void WebCLTransformer::createLocalAddressSpaceTypedef(AddressSpaceInfo &as)
{
    createAddressSpaceTypedef(as, cfg_.localRecordType_, cfg_.getNameOfAlignMacro("local"));
}

void WebCLTransformer::createConstantAddressSpaceTypedef(AddressSpaceInfo &as)
{
    createAddressSpaceTypedef(as, cfg_.constantRecordType_, cfg_.getNameOfAlignMacro("constant"));
}

void WebCLTransformer::createAddressSpaceLimitsTypedef(
    AddressSpaceLimits &limits, const std::string &name)
{
    modulePrologue_ << "typedef struct "
                    << addressSpaceLimitsAsStruct(limits)
                    << " " << name << ";\n\n";
}

void WebCLTransformer::createGlobalAddressSpaceLimitsTypedef(AddressSpaceLimits &asLimits)
{
    createAddressSpaceLimitsTypedef(asLimits, cfg_.globalLimitsType_);
}

void WebCLTransformer::createConstantAddressSpaceLimitsTypedef(AddressSpaceLimits &asLimits)
{
    createAddressSpaceLimitsTypedef(asLimits, cfg_.constantLimitsType_);
}

void WebCLTransformer::createLocalAddressSpaceLimitsTypedef(AddressSpaceLimits &asLimits)
{
    createAddressSpaceLimitsTypedef(asLimits, cfg_.localLimitsType_);
}

void WebCLTransformer::createAddressSpaceLimitsField(
    const std::string &type, const std::string &name)
{
    modulePrologue_ << cfg_.indentation_ << type << " " << name << ";\n";
}

void WebCLTransformer::createAddressSpaceNullField(
    const std::string &name, unsigned addressSpace)
{
    modulePrologue_ << cfg_.indentation_
                    << "__" << cfg_.getNameOfAddressSpace(addressSpace)
                    << " " << cfg_.nullType_ << " *" << name << ";\n";
}

void WebCLTransformer::createProgramAllocationsTypedef(
    AddressSpaceLimits &globalLimits, AddressSpaceLimits &constantLimits,
    AddressSpaceLimits &localLimits, AddressSpaceInfo &privateAs)
{
    modulePrologue_ << "typedef struct {\n";
    if (!globalLimits.empty()) {
        createAddressSpaceLimitsField(cfg_.globalLimitsType_, cfg_.globalLimitsField_);
        createAddressSpaceNullField(cfg_.globalNullField_, globalLimits.getAddressSpace());
    }
    if (!constantLimits.empty()) {
        createAddressSpaceLimitsField(cfg_.constantLimitsType_, cfg_.constantLimitsField_);
        createAddressSpaceNullField(cfg_.constantNullField_, constantLimits.getAddressSpace());
    }
    if (!localLimits.empty()) {
        createAddressSpaceLimitsField(cfg_.localLimitsType_, cfg_.localLimitsField_);
        createAddressSpaceNullField(cfg_.localNullField_, localLimits.getAddressSpace());
    }
    if (!privateAs.empty()) {
        modulePrologue_ << cfg_.indentation_ << cfg_.privateRecordType_<< " " << cfg_.privatesField_ << ";\n";
        createAddressSpaceNullField(cfg_.privateNullField_, 0);
    }
    modulePrologue_ << "} " << cfg_.addressSpaceRecordType_ << ";\n\n";
}

void WebCLTransformer::createConstantAddressSpaceAllocation(AddressSpaceInfo &as)
{
    if (!as.empty()) {
        modulePrologue_ << "__" << cfg_.constantAddressSpace_ << " "
                        << cfg_.constantRecordType_ << " "
                        << cfg_.constantRecordName_ << " = "
                        << addressSpaceInitializer(as) << ";\n\n";
    }
}

void WebCLTransformer::createLocalAddressSpaceAllocation(clang::FunctionDecl *kernelFunc)
{
    std::ostream &out = functionPrologue(kernelPrologues_, kernelFunc);

    out << "\n" << cfg_.indentation_ << "__" << cfg_.localAddressSpace_ << " "
        << cfg_.localRecordType_ << " " << cfg_.localRecordName_ << ";\n";
}

void WebCLTransformer::createAddressSpaceLimitsInitializer(
    std::ostream &out, clang::FunctionDecl *kernel, AddressSpaceLimits &limits)
{
    out << cfg_.getIndentation(2) << addressSpaceLimitsInitializer(kernel, limits);
    out << ",\n" << cfg_.getIndentation(2);
    createAddressSpaceLimitsNullInitializer(out, limits.getAddressSpace());
}

void WebCLTransformer::createProgramAllocationsAllocation(
    clang::FunctionDecl *kernelFunc, AddressSpaceLimits &globalLimits,
    AddressSpaceLimits &constantLimits, AddressSpaceLimits &localLimits,
    AddressSpaceInfo &privateAs)
{
    std::ostream &out = functionPrologue(kernelPrologues_, kernelFunc);

    out << "\n" << cfg_.indentation_
        << cfg_.addressSpaceRecordType_ << " " << cfg_.programRecordName_ << " = {\n";

    bool hasPrev = false;

    if (!globalLimits.empty()) {
        createAddressSpaceLimitsInitializer(out, kernelFunc, globalLimits);
        hasPrev = true;
    }

    if (!constantLimits.empty()) {
        if (hasPrev) {
            out << ",\n";
        }
        createAddressSpaceLimitsInitializer(out, kernelFunc, constantLimits);
        hasPrev = true;
    }

    if (!localLimits.empty()) {
        if (hasPrev) {
            out << ",\n";
        }
        createAddressSpaceLimitsInitializer(out, kernelFunc, localLimits);
        hasPrev = true;
    }

    if (!privateAs.empty()) {
      if (hasPrev) {
            out << ",\n";
      }
      // we pretty much cannot initialize this in the start since if e.g. variables
      // are used to initialize private variables, we cannot move initialization to start of function
      // since value might be different in that phase.
      out << cfg_.getIndentation(2) << "{ },\n";
      out << cfg_.getIndentation(2) << "0\n";
    }

    out << "\n" << cfg_.indentation_ << "};\n";
    out << cfg_.indentation_ << cfg_.addressSpaceRecordType_ << " *"
        << cfg_.addressSpaceRecordName_ << " = &" << cfg_.programRecordName_ << ";\n";
}

void WebCLTransformer::createAddressSpaceNullAllocation(
    std::ostream &out, unsigned addressSpace)
{
    const bool isLocal = (addressSpace == clang::LangAS::opencl_local);

    if (isLocal)
        out << cfg_.indentation_;

    out << "__" << cfg_.getNameOfAddressSpace(addressSpace) << " "
        << cfg_.nullType_ << " " << cfg_.getNameOfAddressSpaceNull(addressSpace)
        << "[" << cfg_.getNameOfSizeMacro(addressSpace) << "]";

    if (!isLocal)
        out << " = { 0 }";

    out << ";\n";
}

void WebCLTransformer::createConstantAddressSpaceNullAllocation()
{
    createAddressSpaceNullAllocation(modulePrologue_, clang::LangAS::opencl_constant);
}

void WebCLTransformer::createLocalAddressSpaceNullAllocation(clang::FunctionDecl *kernel)
{
    std::ostream &out = functionPrologue(kernelPrologues_, kernel);
    out << "local int hd4k_workaround_local;" << std::endl;
    out << "hd4k_workaround_local = hd4k_workaround_constant;" << std::endl;
    createAddressSpaceNullAllocation(out, clang::LangAS::opencl_local);
}

void WebCLTransformer::initializeAddressSpaceNull(clang::FunctionDecl *kernel,
                                                  AddressSpaceLimits &limits)
{
  // init null only if there is limits.
  if (limits.empty()) return;
  
  std::ostream &out = functionPrologue(kernelPrologues_, kernel);
  
  std::string nullType =  "__" + cfg_.getNameOfAddressSpace(limits.getAddressSpace()) + " " + cfg_.nullType_ + "*";

  out << cfg_.indentation_
      << cfg_.getNameOfAddressSpaceNullPtrRef(limits.getAddressSpace()) << " = ";
  
  int endParenthesis = 0;
  
  if (limits.hasStaticallyAllocatedLimits()) {
      out << "_WCL_SET_NULL(" << nullType << ", " << cfg_.getNameOfSizeMacro(limits.getAddressSpace()) << ", " << cfg_.getStaticLimitRef(limits.getAddressSpace()) << ", ";
      endParenthesis++;
  }
  
  for(AddressSpaceLimits::LimitList::iterator i = limits.getDynamicLimits().begin();
      i != limits.getDynamicLimits().end(); i++) {
      out << "_WCL_SET_NULL(" << nullType << ", " << cfg_.getNameOfSizeMacro(limits.getAddressSpace()) << "," << cfg_.getDynamicLimitRef(*i) << ", ";
    endParenthesis++;
  }
  
  out << "(" << nullType << ")0";
  
  for (int i = 0; i < endParenthesis; i++) {
    out << ")";
  }
  out << ";\n";
  
  out << cfg_.indentation_
      << "if (" << cfg_.getNameOfAddressSpaceNullPtrRef(limits.getAddressSpace()) << " == (" << nullType << ")0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. \n";
}

void WebCLTransformer::createLocalRangeZeroing(
    std::ostream &out, const std::string &arguments)
{
    out << cfg_.indentation_
        << cfg_.localRangeZeroingMacro_ << "(" << arguments << ");\n";
}

void WebCLTransformer::createLocalAreaZeroing(
    clang::FunctionDecl *kernelFunc, AddressSpaceLimits &localLimits)
{
    if (localLimits.empty())
        return;

    std::ostream &out = functionPrologue(kernelPrologues_, kernelFunc);

    out << "\n" << cfg_.indentation_ << "// => Local memory zeroing.\n";

    if (localLimits.hasStaticallyAllocatedLimits()) {
        createLocalRangeZeroing(out, cfg_.getStaticLimitRef(clang::LangAS::opencl_local));
    }

    AddressSpaceLimits::LimitList &dynamicLimits = localLimits.getDynamicLimits();
    for (AddressSpaceLimits::LimitList::iterator i = dynamicLimits.begin();
         i != dynamicLimits.end(); ++i) {
        const clang::ParmVarDecl *decl = *i;
        createLocalRangeZeroing(out, cfg_.getDynamicLimitRef(decl));
    }

    createLocalRangeZeroing(out, cfg_.getNullLimitRef(clang::LangAS::opencl_local));

    out << cfg_.indentation_ << "barrier(CLK_LOCAL_MEM_FENCE);\n";
    out << cfg_.indentation_ << "// <= Local memory zeroing.\n";
}

void WebCLTransformer::replaceWithRelocated(clang::DeclRefExpr *use, clang::VarDecl *decl)
{
  std::string relocatedRef = cfg_.getReferenceToRelocatedVariable(decl);
  std::string original = wclRewriter_.getOriginalText(use->getSourceRange());
  DEBUG( std::cerr << "Replacing: " << original << " with: " << relocatedRef << "\n"; );
  wclRewriter_.replaceText(use->getSourceRange(), relocatedRef);
}

void WebCLTransformer::removeRelocated(clang::VarDecl *decl)
{
  wclRewriter_.removeText(decl->getSourceRange());
}

std::string WebCLTransformer::getCheckFunctionCall(CheckKind kind, std::string addr, std::string type, unsigned size, AddressSpaceLimits &limits)
{
  std::stringstream retVal;

  const unsigned limitCount = limits.count();
  const unsigned addressSpace = limits.getAddressSpace();

  std::string name;
  switch (kind) {
  case CHECK_CLAMP:
      name = cfg_.getNameOfLimitClampFunction(addressSpace, limitCount, type);
      break;
  case CHECK_CHECK:
      name = cfg_.getNameOfLimitCheckFunction(addressSpace, limitCount, type);
      break;
  default:
      assert(0);
  }

  retVal << name << "(" << addr << ", " << size;

  if (limits.hasStaticallyAllocatedLimits()) {
      retVal << ", " << cfg_.getStaticLimitRef(addressSpace, "(" + type + ")");
  }

  for (AddressSpaceLimits::LimitList::iterator i = limits.getDynamicLimits().begin();
       i != limits.getDynamicLimits().end(); i++) {
      retVal << ", " << cfg_.getDynamicLimitRef(*i, "(" + type + ")");
  }

  if (kind == CHECK_CLAMP) {
      retVal << ", (" << type << ")" << cfg_.getNameOfAddressSpaceNullPtrRef(addressSpace);
  }
  retVal << ")";

  // add function implementations afterwards
  usedClampFunctions_.insert(ClampFunctionKey(limits.getAddressSpace(), limitCount, type));
  
  return retVal.str();
}

namespace {
    struct BaseIndexField {
	clang::Expr *base;
	clang::Expr *index;
	std::string  field;
  
	BaseIndexField(clang::Expr *access) : 
	    base(access), index(NULL) 
	{
	    if (clang::MemberExpr *memberExpr = llvm::dyn_cast<clang::MemberExpr>(access)) {
		base = memberExpr->getBase();
		field = memberExpr->getMemberNameInfo().getName().getAsString();

	    } else if (clang::ExtVectorElementExpr *vecExpr =
		llvm::dyn_cast<clang::ExtVectorElementExpr>(access)) {
		base = vecExpr->getBase();
		field = vecExpr->getAccessor().getName().str();
  
	    } else if (clang::ArraySubscriptExpr *arraySubExpr =
		llvm::dyn_cast<clang::ArraySubscriptExpr>(access)) {
		base = arraySubExpr->getBase();
		index = arraySubExpr->getIdx();
    
	    } else if (clang::UnaryOperator *unary = llvm::dyn_cast<clang::UnaryOperator>(access)) {
		base = unary->getSubExpr();
	    }
	}
	
    };
}

std::string WebCLTransformer::getClampFunctionExpression(clang::Expr *access, unsigned size, AddressSpaceLimits &limits)
{
    BaseIndexField     bif(access);
    clang::SourceRange baseRange = clang::SourceRange(bif.base->getLocStart(), bif.base->getLocEnd());
    const std::string  original  = wclRewriter_.getOriginalText(access->getSourceRange());
    const std::string  baseStr   = wclRewriter_.getTransformedText(baseRange);
    std::stringstream  memAddress;

    memAddress << "(" << baseStr << ")";
    std::string indexStr;
    if (bif.index) {
	indexStr = wclRewriter_.getTransformedText(bif.index->getSourceRange());
	memAddress << "+(" << indexStr << ")";
    }
  
    // trust limits given in parameter or check against all limits
    std::string macro = getCheckFunctionCall(CHECK_CLAMP, memAddress.str(), bif.base->getType().getAsString(), size, limits);

    std::stringstream retVal;
    retVal << "(*(" << macro  << "))";
    if (!bif.field.empty()) {
	retVal << "." << bif.field;
    }
	
    return retVal.str();
}

void WebCLTransformer::addMemoryAccessCheck(clang::Expr *access, unsigned size, AddressSpaceLimits &limits)
{
  std::string retVal = getClampFunctionExpression(access, size, limits);
  
  DEBUG(
    std::cerr << "Creating memcheck for: " << original
              << "\n                 base: " << baseStr
              << "\n                index: " << indexStr
              << "\n          replacement: " << retVal
              << "\n----------------------------\n";
    access->dump();
    std::cerr << "============================\n\n"; );
  
  wclRewriter_.replaceText(access->getSourceRange(), retVal);
  DEBUG( std::cerr << "============================\n\n"; );
}

void WebCLTransformer::addRelocationInitializerFromFunctionArg(clang::ParmVarDecl *parmDecl)
{
  const clang::FunctionDecl *parent = llvm::dyn_cast<const clang::FunctionDecl>(parmDecl->getParentFunctionOrMethod());
  // add only once
  if (parameterRelocationInitializations_.count(parmDecl) == 0) {
      std::ostream &out = functionPrologue(functionPrologues_, parent);
      out << "\n" << cfg_.getReferenceToRelocatedVariable(parmDecl) << " = "
          << parmDecl->getNameAsString() << ";\n";
    parameterRelocationInitializations_.insert(parmDecl);
  }
}

void WebCLTransformer::addRelocationInitializer(clang::VarDecl *decl)
{
  clang::SourceLocation addLoc = wclRewriter_.findLocForNext(decl->getLocEnd(), ';');
  clang::SourceRange replaceRange(addLoc, addLoc);
  std::stringstream inits;
  inits << wclRewriter_.getTransformedText(replaceRange) << ";";

  // we have to assign arrays with memcpy
  if (decl->getType().getTypePtr()->isArrayType()) {
    inits << "_WCL_MEMCPY(" << cfg_.getReferenceToRelocatedVariable(decl) << "," << decl->getNameAsString() << ");";
  } else {
    inits << cfg_.getReferenceToRelocatedVariable(decl) << " = " << decl->getNameAsString() << ";";
  }
  wclRewriter_.replaceText(replaceRange, inits.str());

}

void WebCLTransformer::moveToModulePrologue(clang::NamedDecl *decl)
{
    // set typeName if we should make sure that this declaration name is not used multiple times
    std::string typeName;
    if (clang::RecordDecl* structDecl = llvm::dyn_cast<clang::RecordDecl>(decl)) {
        if (structDecl->isAnonymousStructOrUnion() || structDecl->getNameAsString().empty()) {
          error(structDecl->getLocStart(), "Anonymous structs should have been eliminated in this phase.");
          return;
        }

        // ignore forward declarations
        if (structDecl->getDefinition() == structDecl) {
          typeName = structDecl->getDefinition()->getNameAsString();
        }
    } else {
      typeName = decl->getNameAsString();
    }

    // make sure that identically named types are not collected from separate scopes...
    if (!typeName.empty()) {
      if (usedTypeNames_.count(typeName) > 0) {
        error(decl->getLocStart(), std::string("Identically named types aren't supported: " + typeName).c_str());
        return;
      } else {
        info(decl->getLocStart(), std::string("Adding type " + typeName + " to bookkeeping.").c_str());
        usedTypeNames_.insert(typeName);
      }
    }
  
    const std::string typedefText = wclRewriter_.getOriginalText(decl->getSourceRange());
    wclRewriter_.removeText(decl->getSourceRange());
    modulePrologue_ << typedefText << ";\n\n";
}

void WebCLTransformer::flushQueuedTransformations()
{
    wclRewriter_.applyTransformations();
}

void WebCLTransformer::addMinimumRequiredContinuousAreaLimit(unsigned addressSpace,
                                                             unsigned minWidthInBits)
{
    preModulePrologue_ << "#define " << cfg_.getNameOfSizeMacro(addressSpace) << " ("
                       << "((" << minWidthInBits << " + (CHAR_BIT - 1)) / CHAR_BIT)"
                       << ")\n";

    // get aligment rounded to next power of two
    unsigned minAlignment = 1;
    while (minWidthInBits != 0) {
      minWidthInBits = minWidthInBits>>1;
      minAlignment = minAlignment<<1;
    }
    minAlignment = minAlignment>>1;

    preModulePrologue_ << "#define " << cfg_.getNameOfAlignMacro(addressSpace) << " "
                       << "(" << minAlignment << "/CHAR_BIT)\n";
}

void WebCLTransformer::addRecordParameter(clang::FunctionDecl *decl)
{
    std::string parameter = cfg_.addressSpaceRecordType_ + " *" + cfg_.addressSpaceRecordName_;

    if (decl->getNumParams() > 0) {
      clang::SourceLocation addLoc = wclRewriter_.findLocForNext(decl->getLocStart(), '(');
      clang::SourceRange addRange = clang::SourceRange(addLoc, addLoc);
      std::string replacement = wclRewriter_.getOriginalText(addRange) + parameter + ", ";
      wclRewriter_.replaceText(addRange, replacement);
    } else {
      clang::TypeLoc typeLoc = decl->getTypeSourceInfo()->getTypeLoc();
      clang::FunctionTypeLoc funTypeLoc = typeLoc.castAs<clang::FunctionTypeLoc>();
      clang::SourceRange addRange(funTypeLoc.getLParenLoc(), funTypeLoc.getRParenLoc());
      wclRewriter_.replaceText(addRange, "(" + parameter + ")");
    }
}

void WebCLTransformer::addRecordArgument(clang::CallExpr *call)
{
  clang::SourceLocation addLoc = wclRewriter_.findLocForNext(call->getLocStart(), '(');
  std::string allocsArg = cfg_.addressSpaceRecordName_;
  if (call->getNumArgs() > 0) {
    allocsArg += ", ";
  }
  clang::SourceRange addRange = clang::SourceRange(addLoc, addLoc);
  allocsArg = wclRewriter_.getOriginalText(addRange) + allocsArg;
  wclRewriter_.replaceText(addRange, allocsArg);
}

void WebCLTransformer::addSizeParameter(clang::ParmVarDecl *decl)
{
    const std::string parameter =
        cfg_.sizeParameterType_ + " " + cfg_.getNameOfSizeParameter(decl->getName());
    const std::string replacement =
        wclRewriter_.getOriginalText(decl->getSourceRange()) + ", " + parameter;
    wclRewriter_.replaceText(
        decl->getSourceRange(),
        replacement);
}

bool WebCLTransformer::rewritePrologue()
{
    std::ostringstream out;
    emitPrologue(out);

    clang::SourceManager &manager = instance_.getSourceManager();
    clang::FileID file = manager.getMainFileID();
    clang::SourceLocation start = manager.getLocForStartOfFile(file);
    clang::SourceRange range(start, start);
    std::string origStr = wclRewriter_.getTransformedText(range);
    wclRewriter_.replaceText(range, out.str() + origStr);
    return true;
}

bool WebCLTransformer::rewriteKernelPrologue(const clang::FunctionDecl *kernel)
{
    clang::Stmt *body = kernel->getBody();
    if (!body) {
        error(kernel->getLocStart(), "Kernel has no body.");
        return false;
    }
    clang::SourceRange range(body->getLocStart(), body->getLocStart());
    std::string origStr = wclRewriter_.getTransformedText(range) + "\n";
    wclRewriter_.replaceText(range, origStr + functionPrologue(kernelPrologues_, kernel).str());
    return true;
}

void WebCLTransformer::emitVarDeclToStruct(std::ostream &out, const clang::VarDecl *decl)
{
    emitVarDeclToStruct(out, decl, cfg_.getNameOfRelocatedVariable(decl));
}

void WebCLTransformer::emitVarDeclToStruct(std::ostream &out, const clang::VarDecl *decl,
                                    const std::string &name)
{
    clang::QualType type = decl->getType();
    clang::Qualifiers qualifiers = type.getQualifiers();
    qualifiers.removeAddressSpace();
  
    const clang::Type *typePtr = type.getTypePtrOrNull();
 
    std::string variable;
    llvm::raw_string_ostream stream(variable);
    clang::PrintingPolicy policy(instance_.getLangOpts());
  
    // dropping qualifiers from array type is pretty hard... there must be better way to do this
    if (type.getTypePtr()->isArrayType()) {
      clang::QualType unqualArray = instance_.getASTContext().getUnqualifiedArrayType(type, qualifiers);
      clang::QualType fixedType = clang::QualType(unqualArray.getTypePtr(), qualifiers);
      const clang::ConstantArrayType *constArr = llvm::dyn_cast<clang::ConstantArrayType>(fixedType.getTypePtr()->getAsArrayTypeUnsafe());
      assert(constArr && "OpenCL can't have non-constant arrays.");
      out << constArr->getElementType().getAsString() << " " << name << "[" << constArr->getSize().getZExtValue() << "]";

    } else {
      clang::QualType::print(typePtr, qualifiers, stream, policy, name);
      out << stream.str();
    }
}

void WebCLTransformer::emitGeneralCode(std::ostream &out)
{
    const char *buffer = reinterpret_cast<const char*>(general_endlfix_cl);
    size_t length = general_endlfix_cl_len;
    const std::string generalClContents(buffer, length);
    out << "\n" << generalClContents << "\n";
}

void WebCLTransformer::emitLimitFunctions(std::ostream &out)
{
    for (RequiredFunctionSet::iterator i = usedClampFunctions_.begin();
         i != usedClampFunctions_.end(); i++) {
      out << getWclAddrCheckFunctionDefinition(*i) << "\n";
    }

    out << "\n";
}

std::string WebCLTransformer::getWclAddrCheckFunctionDefinition(ClampFunctionKey clamp)
{
    std::stringstream retVal;
    std::stringstream limitCheckDeclArgs;
    std::stringstream limitCheckCallArgs;
    limitCheckDeclArgs << clamp.type << "addr, unsigned size";
    limitCheckCallArgs << "addr, size";
    for (unsigned i = 0; i < clamp.limitCount; i++) {
	limitCheckDeclArgs << ", " << clamp.type << " min" << i << ", " << clamp.type << " max" << i;
	limitCheckCallArgs << ", min" << i << ", max" << i;
    }

    retVal << "bool " << cfg_.getNameOfLimitCheckFunction(clamp.aSpaceNum, clamp.limitCount, clamp.type)
           << "(" << limitCheckDeclArgs.str() << ")\n"
           << "{\n"
           << cfg_.getIndentation(1) << "  return 0";

    // at least one of the limits must match
    for (unsigned i = 0; i < clamp.limitCount; i++) {
	retVal << "\n" << cfg_.getIndentation(2) << "|| "
	       << "( "
	       << "((addr) >= (min" << i << "))"
	       << " && "
	       << "((addr + size - 1) <= " << cfg_.getNameOfLimitMacro() << "(" << clamp.type << ", max" << i << "))"
	       << " )";
    }
    retVal << ";\n"
           << "}\n";
  
    // define clamping function in terms of the checking function
    retVal << clamp.type
           << cfg_.getNameOfLimitClampFunction(clamp.aSpaceNum, clamp.limitCount, clamp.type)
           << "(" << limitCheckDeclArgs.str() << ", " << clamp.type << " asnull)\n"
           << "{\n"
           << cfg_.getIndentation(1)
           << " return "
           << cfg_.getNameOfLimitCheckFunction(clamp.aSpaceNum, clamp.limitCount, clamp.type) 
           << "(" << limitCheckCallArgs.str() << ") ? addr : asnull;\n"
           << "}\n";
  
    return retVal.str();
}

void WebCLTransformer::emitPrologue(std::ostream &out)
{
    out << preModulePrologue_.str();
    out << modulePrologue_.str();
    emitGeneralCode(out);
    emitLimitFunctions(out);
    out << afterLimitFunctions_.str();
}

void WebCLTransformer::emitTypeNullInitialization(
    std::ostream &out, clang::QualType qualType)
{
    const clang::Type *type = qualType.getTypePtrOrNull();
    if (type && type->isArrayType()) {
      out << "{ ";
      emitTypeNullInitialization(out, type->getAsArrayTypeUnsafe()->getElementType());
      out << " }";
    } else if (type && type->isStructureType()) {
      out << "{ }";
    } else {
      out << "0";
    }
}

void WebCLTransformer::emitVariableInitialization(
    std::ostream &out, const clang::VarDecl *decl)
{
    const clang::Expr *init =  decl->getInit();
  
    if (!init || !init->isConstantInitializer(instance_.getASTContext(), false)) {
        emitTypeNullInitialization(out, decl->getType());
        return;
    }

    const std::string original = wclRewriter_.getTransformedText(init->getSourceRange());
    out << original;
}

void WebCLTransformer::changeFunctionCallee(clang::CallExpr *expr, 
    std::string newName)
{
    clang::Expr *callee = expr->getCallee();
    wclRewriter_.replaceText(callee->getSourceRange(), newName);
}

bool WebCLTransformer::wrapFunctionCall(std::string wrapperName, clang::CallExpr *expr, WebCLKernelHandler &kernelHandler)
{
    bool handled = false;
    
    for (FunctionCallWrapperList::iterator wrapperIt = functionWrappers_.begin();
         !handled && wrapperIt != functionWrappers_.end();
         ++wrapperIt) {

        if ((*wrapperIt)->matchesCallExpr(instance_, expr)) {
            WrappedFunction result =
                (*wrapperIt)->wrapFunction(
                    *this, instance_,
                    expr,
                    ExprVector(expr->getArgs(), expr->getArgs() + expr->getNumArgs()),
                    kernelHandler,
                    wclRewriter_);

            if (result.doWrap_) {
                afterLimitFunctions_ << wrappedDeclaration(instance_, result.returnTypeStr_, expr, wrapperName, result.addAddressSpaceRecordArg_) << "\n";

                afterLimitFunctions_ << "{\n" << result.body_ << "}\n";

                changeFunctionCallee(expr, wrapperName);
                if (result.addAddressSpaceRecordArg_) {
                  addRecordArgument(expr);
                }
            }
	
            handled = true;
        }
    }

    return handled;
}

bool WebCLTransformer::wrapVariableDeclaration(clang::VarDecl *varDecl, WebCLKernelHandler &kernelHandler)
{
    bool handled = false;

    for (FunctionCallWrapperList::iterator wrapperIt = functionWrappers_.begin();
         !handled && wrapperIt != functionWrappers_.end();
         ++wrapperIt) {
        if ((*wrapperIt)->matchesVarDecl(instance_, varDecl)) {
            (*wrapperIt)->wrapDeclaration(
                *this, instance_,
                varDecl,
                kernelHandler,
                wclRewriter_);
            handled = true;
        }
    }

    return handled;
}
